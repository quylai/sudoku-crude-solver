------------------
----------------------------------------
----------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------
prtSudoku hardcode

i=0
	print("-------------------")

	print('|', end='')		b|

	print(x, end='')		x
	print(' ', end='')		s
i=1
	print(x, end='')		x
	print(' ', end='')		s
i=2
	print(x, end='')		x
	print('|', end='')		|
i=3
	print(x, end='')		x
	print(' ', end='')		s
i=4
	print(x, end='')		x
	print(' ', end='')		s
i=5
	print(x, end='')		x
	print('|', end='')		|
i=6
	print(x, end='')		x
	print(' ', end='')		s
i=7
	print(x, end='')		x
	print(' ', end='')		s
i=8
	print(x, end='')		x
	print('|')			|e
i=9
	print('|', end='')		b|

	print(x, end='')		x
	print(' ', end='')		s
i=10
	print(x, end='')		x
	print(' ', end='')		s
i=11
	print(x, end='')		x
	print('|', end='')		|
i=12
	print(x, end='')		x
	print(' ', end='')		s
i=13
	print(x, end='')		x
	print(' ', end='')		s
i=14
	print(x, end='')		x
	print('|', end='')		|
i=15
	print(x, end='')		x
	print(' ', end='')		s
i=16
	print(x, end='')		x
	print(' ', end='')		s
i=17
	print(x, end='')		x
	print('|')			|e
i=18
	print('|', end='')		b|

	print(x, end='')		x
	print(' ', end='')		s
i=19
	print(x, end='')		x
	print(' ', end='')		s
i=20
	print(x, end='')		x
	print('|', end='')		|
i=21
	print(x, end='')		x
	print(' ', end='')		s
i=22
	print(x, end='')		x
	print(' ', end='')		s
i=23
	print(x, end='')		x
	print('|', end='')		|
i=24
	print(x, end='')		x
	print(' ', end='')		s
i=25
	print(x, end='')		x
	print(' ', end='')		s
i=26
	print(x, end='')		x
	print('|')			|e


#-----------------
Above are hardcode of function "prtSudoku" from indices 0 to 26.  Annotation are as followed:
{b|}	row beginning bar
{x}	cell value
{|e}	row ending bar
{|}	between cells bar
{s}	space between cells


#-----------------
About function prtSudoku
.
Argument of grid is reduce to 1D array {oneline_sudoku}.  It is iterated thru for-loop to make necessary arrangement for outputting onto command line.  Method "ndenumerate" allow access to array indices {idx} and its corresponding values {x}.  {idx} is given in tuple of one item, of type "int".



----------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------
function: find_inter_coord (find intersected coordinates)

location: -
args: grid, linesSeq, rowsOrCols
constraint: definition listing needed to be b4 func:
	    "rowsComp", "colsComp", "nCount", and "analyzeSeqs"


- grid is 2D sudoku grid itself
- linesSeq is lines sequence currently processing
- rowsOrCols is 'r' or 'c' to annotate whether intersection process is between 
  rows or cols


arrA & arrB are 1D array that will be used to find all intersected values "inter_val" and their indices "inter_val_coord" (intersected value coordinates)
.
arrC is there to be compare with "inter_val", if value of "inter_val" matched with arrC, then that element in inter_val needed to be deleted

----------------------------------------
{inter_val} is an array contains intersected values between arrA & arrB
{interWithArrC} is an array contains intersected values between inter_val & arrC


----------------------------------------
    for idx, i in np.ndenumerate(inter_val):
      for j in interWithArrC:
        if (i == j):
          inter_val[idx[0]] = 0
----------------------------------------
turn all value of inter_val that matched with interWithArrC, to 0


----------------------------------------
    inter_val = np.sort(inter_val)
    while (np.where(inter_val == 0)[0].size != 0):
      temp = inter_val
      inter_val = np.delete(temp, [0])
----------------------------------------
need to sort inter_val to have all the zeroes move to beginning of array
.
while condition:
"where...[0]" contain an array of indices where all value 0 appear on array inter_val, therefore if 0 exist then indices array size is not 0
.
doing switcheroo with temp to delete first index of inter_val


----------------------------------------
    inter_val_coord = np.array([], dtype=int)
    for idx, x in np.ndenumerate(inter_val):

      j = np.where(arrA == x)[0]
      k = np.where(arrB == x)[0]

      # append intersected indices from arrA & arrB
      inter_val_coord = np.append(inter_val_coord, [j, k]).reshape(idx[0]+1, 2)
----------------------------------------

------------------
    inter_val_coord = np.array([], dtype=int)
------------------
.
need to have inter_val_coord initialized in order to do the appendings later

------------------
    for idx, x in np.ndenumerate(inter_val):
      ...
------------------
.
"ndenumerate" allow index (idx) and its value (x) accessible, while iterating thru inter_val; finding all value of inter_val, match that in arrA & arrB, locate its indices, assign to j & k, respectively;
j & k become a 1 x 2 array, which "append" to inter_val_coord (still 1D array at this point), then "reshape" into array [idx[0]+1]_by_[2]

------------------
    return inter_val, inter_val_coord
------------------



----------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------
function: procThirdRow (processing third row)

location: inside func rowsComp
args: grid, info, curRowsSeq

info[0] is intersected values array
info[1] is intersected coordinates array 
info[1][0] is index of row1;
info[1][1] is index of row2,
curRowsSeq (current rows sequence)

------------------
    for idx, i in np.ndenumerate(info[0]):  # in intersected value
------------------
.
iterating thru intersected values array


------------------
      rowBlocOccupy = np.array([0,0,0])
------------------
.
array of flag to mark (with 1) which row block occupied by arrA and arrB


------------------
      for j in info[1][idx]:  # in intersected coord
        for k in range(9): 
------------------
iterating thru target set of intersected coord array, evaluating which element of rowBlocOccupy to flag (1=occupied, 0=open) depending on row1 and row2 indices


------------------
      for xdx, x in np.ndenumerate(rowBlocOccupy):
        if (x == 0):
          if (xdx[0] == 0):
            tarRowBlocInd = [0,1,2]
          elif (xdx[0] == 1):
            tarRowBlocInd = [3,4,5]
          elif (xdx[0] == 2):
            tarRowBlocInd = [6,7,8]
------------------
.
assigning which indices set would be for tarRowBlocInd (target row block indices)


------------------
      rowBlocElement = [8,8,8]  # initializing
      for ydx, y in np.ndenumerate(tarRowBlocInd):
        if (grid[curRowsSeq[2]][y] == 0):
          rowBlocElement[ydx[0]] = 0
        else:
          rowBlocElement[ydx[0]] = 1
------------------
.
recalled grid[curRowsSeq[2]] is arrC;
scanning tarRowBlocInd, flagging 1=occupied or 0=vacant, onto rowBlocElement


----------------------------------------
      dummyRBE = rowBlocElement.copy()
      if (np.where(dummyRBE == 0)[0].size >= 2):
        for z in np.where(dummyRBE == 0)[0]:
          dummyCol = grid[:, tarRowBlocInd[z]]
          for a in dummyCol:
            if (a == i):
              rowBlocElement[z] = 1
----------------------------------------
.
needed temp variable dummyRBE to clone rowBlocElement array, since value of rowBlocElement is possibly changing within the for loop
.
------------------
      if (np.where(dummyRBE == 0)[0].size >= 2):
------------------
.
in the case of all 3 cells of dummyRBE empty, which is dummyRBE = [0,0,0] then
np.where(dummyRBE == 0)[0].size
will have 3 elements; likewise, 2 cells empty equal to 2 elements
.
np.where(dummyRBE == 0)[0]
= an array of indices where 0 value is found in rowBlocElement array
.
np.where(dummyRBE == 0)[0][0]
= value of first indices where 0 value is found in rowBlocElement array
.
------------------
          dummyCol = grid[:, tarRowBlocInd[z]]
------------------
generating a cross-column (dummyCol) at current empty element
.
------------------
          for a in dummyCol:
            if (a == i):
              rowBlocElement[z] = 1
------------------
.
when element of column matched with currently iterated element of intersected values array; rowBlocElement is flagged 


----------------------------------------
      if (np.where(rowBlocElement == 0)[0].size == 1):
----------------------------------------
when there is a single vacant in rowBlocElement; meaning:
[0,1,1] or [1,0,1] or [1,1,0]
then current iterated value in intersected values array is the value for that vacant spot
.
np.where(rowBlocElement == 0)[0]
= an array of indices where 0 value is found in rowBlocElement array
.
np.where(rowBlocElement == 0)[0][0]
= value of first indices where 0 value is found in rowBlocElement array



----------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------
function: procThirdCol (processing third col)

location: inside func colsComp
args: grid, info, curColsSeq

coding of procThirdCol is almost identical to procThirdRow, except for some detail below


------------------
      for ydx, y in np.ndenumerate(tarColBlocInd):
        if (grid[y:y+1, curColsSeq[2]] == 0):
	...
------------------
         ...grid[y:y+1, curColsSeq[2]]...
is how traversing column done in numpy; syntax are as follow:
------------------
import numpy as np
arr2D = np.array([[1,2,3], [4,5,6], [7,8,9]])
------------------
.
testArr = arr2D[a:b, j]
.
on col_index=j, select row_index=a to row_index=(b-1);
if b is not given, selection is to the last row


------------------
          dummyRow = grid[tarColBlocInd[z],]
------------------
another differences


------------------
        grid[tarColBlocInd[np.where(colBlocElement == 0)[0][0]], curColsSeq[2]] = i
------------------
when there is a single vacant in colBlocElement; meaning:
[0,1,1] or [1,0,1] or [1,1,0]
then current iterated value in intersected values array is the value for that vacant spot
.
np.where(colBlocElement == 0)[0]
= an array of indices where 0 value is found in rowBlocElement array
.
np.where(colBlocElement == 0)[0][0]
= value of first indices where 0 value is found in rowBlocElement array



----------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------
function: singCand (single candidate)

location: -
args: grid
constraint: definition listing needed to be, 
	    after func:
	    "rowsComp" and "colsComp",
            before:
            "nCount" and "analyzeSeqs"

------------------
boxVects
is an array of 9-by-4, contain boxes vetors value to partition grid into boxes;
.
example:
boxVects[0,] has [0 3 0 3], apply those values to grid array like so
.
grid[0:3, 0:3]
now, that is the definition of "box0"


------------------
viaBoxes
is an array of flags, denoting which box is viable for single-candidate processing;
.
respective box would be flag 1, if the box has >= 4 cells 








----------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------
function: nCount (numbers count)

location: -
args: grid
constraint: definition listing needed to be b4 "analyzeSeqs" func

this function simply counts how many cells have been filled



----------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------
function: analyzeSeqs (numbers count)

location: -
args: grid, *seqsOfStr
constraint: definition listing needed to be after "nCount", "rowsComp",
	    and "colsComp" func

------------------
analyzeSeqs(grid, "rrrr", "cccc")
------------------
.
give codes above, output:
.
------------------
initially: 32; ran sequence rrrr, now 38; solved 6
initially: 32; ran sequence cccc, now 36; solved 4
------------------
.
1st line:
    sudoku initially has 32 cells filled; rows comparison (rowsComp) ran 4 times,
    now there are 38 cells filled; therefore 6 cells have been solved
2nd line:
    same verbiage; 'c' is cols comparison (colsComp)

































