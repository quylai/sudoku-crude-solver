------------------
----------------------------------------
----------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------
function: find_inter_coord
args: arrA, arrB, arrC

arrA & arrB are 1D array that will be used to find all value intersected "inter_val" and their indices "inter_val_coord" (intersected value coordinates)
.
arrC is there to be compare with "inter_val", if value of "inter_val" matched with arrC, then that element in inter_val needed to be deleted

----------------------------------------
{inter_val} is an array contains intersected values between arrA & arrB
{interWithRow3} is an array contains intersected values between inter_val & arrC


----------------------------------------
    for idx, i in np.ndenumerate(inter_val):
      for j in interWithRow3:
        if (i == j):
          inter_val[idx[0]] = 0
----------------------------------------
turn all value of inter_val that matched with interWithRow3, to 0


----------------------------------------
    inter_val = np.sort(inter_val)
    while (np.where(inter_val == 0)[0].size != 0):
      temp = inter_val
      inter_val = np.delete(temp, [0])
----------------------------------------
need to sort inter_val to have all the zeroes move to beginning of array
.
while condition:
"where...[0]" contain an array of indices where all value 0 appear on array inter_val, therefore if 0 exist then array size is not not 0
.
doing switcheroo with temp to delete first index of inter_val


----------------------------------------
    inter_val_coord = np.array([], dtype=int)
    for idx, x in np.ndenumerate(inter_val):

      j = np.where(arrA == x)[0]
      k = np.where(arrB == x)[0]

      # append intersected indices from arrA & arrB
      inter_val_coord = np.append(inter_val_coord, [j, k]).reshape(idx[0]+1, 2)
----------------------------------------

------------------
    inter_val_coord = np.array([], dtype=int)
------------------
.
need to have inter_val_coord initialize in order to do the appendings later

------------------
    for idx, x in np.ndenumerate(inter_val):
------------------
.
"ndenumerate" allow index (idx) and its value (x), accessible while iterating thru inter_val; finding all value of inter_val, match that in arrA & arrB, locate its indices, assign to j & k, respectively;
j & k become a 1 x 2 , which "append" to inter_val_coord (still 1D array at this point), then "reshape" into array [idx[0]+1]_by_[2]

------------------
    return inter_val, inter_val_coord
------------------



----------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------
function: procThird
args: grid, info

info[0] is value list
info[1] is coord list; info[1][0] is index of row1; info[1][1] is index of row2,


------------------
    for idx, i in np.ndenumerate(info[0]):  # in intersected value
------------------
.
iterating thru intersected values array


------------------
      rowBlocOccupy = [0,0,0]
------------------
.
array of flag to mark (with 1) which row block occupied by row1 and row2


------------------
      for j in info[1][idx]:  # in intersected coord
        for k in range(9): 
------------------
iterating thru target set of intected coord array, evaluate which element of rowBlocOccupy to flag depending on row1 and row2 indices


------------------
      for xdx, x in np.ndenumerate(rowBlocOccupy):
        if (x == 0):
          if (xdx[0] == 0):
            tarRowBlocInd = [0,1,2]
          elif (xdx[0] == 1):
            tarRowBlocInd = [3,4,5]
          elif (xdx[0] == 2):
            tarRowBlocInd = [6,7,8]
------------------
.
deciding which indices set would be tarRowBlocInd (target row block indices)


------------------
      rowBlocElement = [8,8,8]  # initializing
      for ydx, y in np.ndenumerate(tarRowBlocInd):
        if (row3[y] == 0):
          rowBlocElement[ydx[0]] = 0
        else:
          rowBlocElement[ydx[0]] = 1
------------------
.
of tarRowBlocInd, flagging 1=occupied or 0=vacant


------------------
      if (np.where(rowBlocElement == 0)[0].size == 1):
------------------
when there is a single vacant in rowBlocElement; meaning:
[0,1,1] or [1,0,1] or [1,1,0]
then current iterated value in intersected values array is the value for that vacant spot
.
np.where(rowBlocElement == 0)[0]
= an array of indices where 0 value is found in rowBlocElement array
.
np.where(rowBlocElement == 0)[0][0]
= value of first indices where 0 value is found in rowBlocElement array
















