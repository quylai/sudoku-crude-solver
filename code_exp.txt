------------------
----------------------------------------
----------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------
function: find_inter_coord
args: arrA, arrB, arrC

arrA & arrB are 1D array that will be used to find all value intersected "inter_val" and their indices "inter_val_coord" (intersected value coordinates)
.
arrC is there to be compare with "inter_val", if value of "inter_val" matched with arrC, then that element in inter_val needed to be deleted

----------------------------------------
{inter_val} is an array contains intersected values between arrA & arrB
{interWithRow3} is an array contains intersected values between inter_val & arrC


----------------------------------------
    for idx, i in np.ndenumerate(inter_val):
      for j in interWithRow3:
        if (i == j):
          inter_val[idx[0]] = 0
----------------------------------------
turn all value of inter_val that matched with interWithRow3, to 0


----------------------------------------
    inter_val = np.sort(inter_val)
    while (np.where(inter_val == 0)[0].size != 0):
      temp = inter_val
      inter_val = np.delete(temp, [0])
----------------------------------------
need to sort inter_val to have all the zeroes move to beginning of array
.
while condition:
"where...[0]" contain an array of indices where all value 0 appear on array inter_val, therefore if 0 exist then array size is not not 0
.
doing switcheroo with temp to delete first index of inter_val


----------------------------------------
    inter_val_coord = np.array([], dtype=int)
    for idx, x in np.ndenumerate(inter_val):

      j = np.where(arrA == x)[0]
      k = np.where(arrB == x)[0]

      # append intersected indices from arrA & arrB
      inter_val_coord = np.append(inter_val_coord, [j, k]).reshape(idx[0]+1, 2)
----------------------------------------

------------------
    inter_val_coord = np.array([], dtype=int)
------------------
.
need to have inter_val_coord initialize in order to do the appendings later

------------------
    for idx, x in np.ndenumerate(inter_val):
------------------
.
"ndenumerate" allow index (idx) and its value (x), accessible while iterating thru inter_val; finding all value of inter_val, match that in arrA & arrB, locate its indices, assign to j & k, respectively;
j & k become a 1 x 2 , which "append" to inter_val_coord (still 1D array at this point), then "reshape" into array [idx[0]+1]_by_[2]

------------------
    return inter_val, inter_val_coord
------------------










